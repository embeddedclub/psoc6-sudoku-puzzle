/*
 * tft_task.c
 *
 *  Created on: 29-Jun-2021
 *      Author: Embedded Club (www.embedded.club)
 */
/******************************************************************************
*
* File Name: tft_task.c
*
* Description: This sudoku core implementation with puzzle template. The puzzle
* 			   template can be generated by adding aditional algorothim which is
               not part of this code. soon will be updated by Embedded Club
*
*******************************************************************************
* (c) 2020, Cypress Semiconductor Corporation. All rights reserved.
*******************************************************************************
* This software, including source code, documentation and related materials
* ("Software"), is owned by Cypress Semiconductor Corporation or one of its
* subsidiaries ("Cypress") and is protected by and subject to worldwide patent
* protection (United States and foreign), United States copyright laws and
* international treaty provisions. Therefore, you may use this Software only
* as provided in the license agreement accompanying the software package from
* which you obtained this Software ("EULA").
*
* If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
* non-transferable license to copy, modify, and compile the Software source
* code solely for use in connection with Cypress's integrated circuit products.
* Any reproduction, modification, translation, compilation, or representation
* of this Software except as specified above is prohibited without the express
* written permission of Cypress.
*
* Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT, IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. Cypress
* reserves the right to make changes to the Software without notice. Cypress
* does not assume any liability arising out of the application or use of the
* Software or any product or circuit described in the Software. Cypress does
* not authorize its products for use in any products where a malfunction or
* failure of the Cypress product may reasonably be expected to result in
* significant property damage, injury or death ("High Risk Product"). By
* including Cypress's product in a High Risk Product, the manufacturer of such
* system or application assumes all risk of such use and in doing so agrees to
* indemnify Cypress against all liability.
*******************************************************************************/

#include "cy_pdl.h"
#include "cyhal.h"
#include "cybsp.h"
#include "GUI.h"
#include "mtb_st7789v.h"
#include "bitmaps.h"
#include "tft_task.h"
#include "FreeRTOS.h"
#include "task.h"
#include "timers.h"
#include "queue.h"
#include "cy_retarget_io.h"
#include "capsense_task.h"
#include "audio.h"
#include "cy_rgb_led.h"

#define STARTUP_DELAY               (2000/*ms*/) /* Amount of time to show the startup logo */
#define NUMBER_OF_DEMO_PAGES        (9u)


#define TFT_TASK_PRIORITY          (1)
#define TASK_LED_PRIORITY		   (1)
#define TASK_CAPSENSE_PRIORITY      (1)
#define TASK_CAPSENSE_STACK_SIZE    (512)
#define TASK_LED_STACK_SIZE         (512)

/* Queue lengths of message queues used in this project */
#define SINGLE_ELEMENT_QUEUE        (1u)
#define printf //
/* The pins are defined by the st7789v library. If the display is being used on different hardware the mappings will be different. */
const mtb_st7789v_pins_t tft_pins =
{
    .db08 = CYBSP_J2_2,
    .db09 = CYBSP_J2_4,
    .db10 = CYBSP_J2_6,
    .db11 = CYBSP_J2_10,
    .db12 = CYBSP_J2_12,
    .db13 = CYBSP_D7,
    .db14 = CYBSP_D8,
    .db15 = CYBSP_D9,
    .nrd  = CYBSP_D10,
    .nwr  = CYBSP_D11,
    .dc   = CYBSP_D12,
    .rst  = CYBSP_D13
};


/*******************************************************************************
* Forward Function Prototypes
*******************************************************************************/
void show_startup_screen(void);
void show_instructions_screen(void);
void wait_for_switch_press_and_release(void);
void fill_box(uint8_t row,uint8_t col, uint8_t color);
void fill_boxOnly(uint8_t row,uint8_t col, uint8_t color_index);
void goto_box(uint8_t x, uint8_t y);
void sudoku_load(uint8_t type);
void show_sudoku_bg(uint8_t index);
points_t* get_current_index();
static uint8_t check_result(uint8_t mode);
static void game_timer_callback(TimerHandle_t xTimer);

/* FreeRTOS task handle for this task. */
TaskHandle_t gui_task_handle;

/* Queue handle for ble app data */
QueueHandle_t gui_capsense_data_q;

/* Holds the connection ID */
volatile uint16_t ble_connection_id = 0;
/* Holds the capsense data */
gui_capsense_data_t gui_cap_data;

int8_t game_mode = 0;

/* TimerHandle for the cloud timer */
TimerHandle_t game_timer_handle;

uint8_t xinc,yinc=0;
uint8_t button_prev =0;

uint32_t score = 0;
uint32_t solved = 0;
const uint32 box_color[7u] =
{
	GUI_GRAY_AA, //GREY
	GUI_RED, //RED
	GUI_BLUE, //BLUE,
	GUI_GREEN, //GREEN,
	GUI_YELLOW, //YELLOW,
	GUI_MAGENTA, //MAGENTA
	GUI_CYAN, //CYAN,
};

const uint32_t led_color[7] =
{
  CY_RGB_LED_COLOR_OFF,
  CY_RGB_LED_COLOR_RED,  //1
  CY_RGB_LED_COLOR_BLUE,   //2
  CY_RGB_LED_COLOR_GREEN,  //3
  CY_RGB_LED_COLOR_YELLOW,  //4
  CY_RGB_LED_COLOR_MAGENTA,  //5
  CY_RGB_LED_COLOR_CYAN  //6
};


const uint8_t sudoku_table_easy[6][6] = {

		{0,5,0, 0,0,1},
		{0,0,4, 6,0,0},

		{4,0,0, 0,5,0},
		{1,0,0, 0,0,4},

		{0,4,3, 0,0,0},
		{0,6,0, 2,4,0},
};

const uint8_t sudoku_table_easy_sol[6][6] = {

		{6,5,2, 4,3,1},
		{3,1,4, 6,2,5},

		{4,3,6, 1,5,2},
		{1,2,5, 3,6,4},

		{2,4,3, 5,1,6},
		{5,6,1, 2,4,3},
};

const uint8_t sudoku_table_medium[6][6] = {

		{0,3,0, 6,0,5},
		{0,4,0, 0,0,0},

		{3,0,0, 0,0,0},
		{0,0,0, 3,6,0},

		{5,0,2, 0,0,6},
		{0,0,0, 5,0,1},
};

const uint8_t sudoku_table_medium_sol[6][6] = {

		{2,3,1, 6,4,5},
		{6,4,5, 2,1,3},

		{3,2,6, 1,5,4},
		{1,5,4, 3,6,2},

		{5,1,2, 4,3,6},
		{4,6,3, 5,2,1},
};



const uint8_t sudoku_table_hard[6][6] = {

		{5,0,6, 0,0,0},
		{0,0,0, 0,2,0},

		{0,6,0, 0,0,0},
		{0,0,0, 5,0,1},

		{0,0,4, 0,0,0},
		{0,0,0, 1,0,3},
};

const uint8_t sudoku_table_hard_sol[6][6] = {

		{5,2,6, 3,1,4},
		{4,3,1, 6,2,5},

		{1,6,5, 4,3,2},
		{2,4,3, 5,6,1},

		{3,1,4, 2,5,6},
		{6,5,2, 1,4,3},
};

uint8_t sudoku_table_now[6][6] = {

		{0,0,0, 0,0,0},
		{0,0,0, 0,0,0},

		{0,0,0, 0,0,0},
		{0,0,0, 0,0,0},

		{0,0,0, 0,0,0},
		{0,0,0, 0,0,0},
};

points_t table_index[6][6] = {

		{{5,5},{43,5},{81,5},{121,5},{159,5},{197,5}},
		{{5,43},{43,43},{81,43},{121,43},{159,43},{197,43}},
		{{5,83},{43,83},{81,83},{121,83},{159,83},{197,83}},
		{{5,121},{43,121},{81,121},{121,121},{159,121},{197,121}},
		{{5,161},{43,161},{81,161},{121,161},{159,161},{197,161}},
		{{5,199},{43,199},{81,199},{121,199},{159,199},{197,199}},
};

points_t cur_index[6][6] = {

		{{23,23},{61,23},{99,23},{139,23},{177,23},{215,23}},
		{{23,61},{61,61},{99,61},{139,61},{177,61},{215,61}},
		{{23,101},{61,101},{99,101},{139,101},{177,101},{215,101}},
		{{23,139},{61,139},{99,139},{139,139},{177,139},{215,139}},
		{{23,179},{61,179},{99,179},{139,179},{177,179},{215,179}},
		{{23,217},{61,217},{99,217},{139,217},{177,217},{215,2}},
};

cursor_t index_now = {{0,0},{0,0}};

/* Variable to denote required GUI updates. */
static uint32_t game_timer=0;
uint8_t sec,min;
uint8_t timer_str[] = {'0','0',':','0','0'};
uint8_t score_str[] = {'0','0','0'};
/*******************************************************************************
* Function Name: game_timer_callback
********************************************************************************
* Summary:
*  game timer callback.
*
* Parameters:
*  TimerHandle_t xTimer (unused)
*
*******************************************************************************/
static void game_timer_callback(TimerHandle_t xTimer)
{
	gui_capsense_data_t gui_time;
    (void)xTimer;

    game_timer++;
    gui_time.buttonstatus2 = 1;
    gui_time.buttonstatus1 = 0xff;
    xQueueSendToFrontFromISR(gui_capsense_data_q,&gui_time,0u);

}


/*******************************************************************************
* Function Name: check_result
********************************************************************************
*
* Summary: This function check the result.
*
* Parameters: mode - game type
*
* Return:
*  None
*
*******************************************************************************/

static uint8_t check_result(uint8_t mode)
{
	uint8_t i=0,j=0;
	uint8_t result = 0;

	for(i=0;i<6;i++)
	{
		for(j=0;j<6;j++)
		{

			if(mode == 0)
			{
				if( sudoku_table_easy_sol[i][j] != sudoku_table_now[i][j])
				{
					result++;
				}
			}
			if(mode == 1)
			{
				if( sudoku_table_medium_sol[i][j] != sudoku_table_now[i][j])
				{
					result++;
				}
			}

			if(mode == 2)
			{
				if( sudoku_table_hard_sol[i][j] != sudoku_table_now[i][j])
				{
					result++;
				}
			}

		}


	}


	return result;

}


/*******************************************************************************
* Function Name: tft_task
********************************************************************************
*
* Summary: This is main task of this puzzle to handle everything.
*
* Parameters: *arg -  not used
*
* Return:
*  None
*
*******************************************************************************/
void tft_task(void *arg)
{
    cy_rslt_t result;
    uint8_t page_number = 0;
    BaseType_t rtos_api_result = pdFAIL;
    uint8_t color_index =0;

    /* Initialize the User Button */
    cyhal_gpio_init(CYBSP_USER_BTN, CYHAL_GPIO_DIR_INPUT, CYHAL_GPIO_DRIVE_PULLUP, CYBSP_BTN_OFF);

    /* Initialize the display controller */
    result = mtb_st7789v_init8(&tft_pins);
    CY_ASSERT(result == CY_RSLT_SUCCESS);
    
    /* Initialize game timer to publish data with 2sec interval */
      game_timer_handle = xTimerCreate ("Game Timer", 1000u,
                                           pdTRUE, NULL, game_timer_callback);

    /* To avoid compiler warning */
    (void)result;
    
    GUI_Init();

    show_sudoku_bg(0);

    GUI_DrawBitmap(&bmeasy_active, 23, 112);
    printf("The Game Menu!\r\n");

    xTaskNotify(audio_task_handle, 2u, eSetValueWithoutOverwrite);


do{


    /* Block until a command has been received over queue */
    result = xQueueReceive(gui_capsense_data_q, &gui_cap_data,
                        500);
		if(gui_cap_data.buttonstatus1 == 2)
		{

			game_mode++;
			if(game_mode > 2) game_mode = 0;
		}
		else if(gui_cap_data.buttonstatus1== 1)
		{

			game_mode--;
			if(game_mode < 0) game_mode = 2;
		}

		if(gui_cap_data.buttonstatus1 !=0){
		switch(game_mode)
		{

		case 0:

			GUI_DrawBitmap(&bmeasy_active, 23, 112);
		    /* Notify the audio task to play tone. */
		    xTaskNotify(audio_task_handle, 0u, eSetValueWithoutOverwrite);

			break;
		case 1:

			GUI_DrawBitmap(&bmmedium_active, 23, 112);
		    /* Notify the audio task to play tone. */
		    xTaskNotify(audio_task_handle, 0u, eSetValueWithoutOverwrite);

			break;
		case 2:

			GUI_DrawBitmap(&bmhard_active, 23, 112);
		    /* Notify the audio task to play tone. */
		    xTaskNotify(audio_task_handle, 0u, eSetValueWithoutOverwrite);

			break;
		default:
			break;

		}

		}
		gui_cap_data.buttonstatus1=0;

		vTaskDelay(10);

}while(cyhal_gpio_read(CYBSP_USER_BTN) != CYBSP_BTN_PRESSED);

/* Notify the audio task to play tone. */
xTaskNotify(audio_task_handle, 0u, eSetValueWithoutOverwrite);

/* Wait for SW2 to be released */
while(cyhal_gpio_read(CYBSP_USER_BTN) == CYBSP_BTN_OFF);
if(game_mode ==0) GUI_DrawBitmap(&bmstart_easy, 23, 112);
if(game_mode ==1) GUI_DrawBitmap(&bmstart_medium, 23, 112);
if(game_mode ==2) GUI_DrawBitmap(&bmstart_hard, 23, 112);
printf("The Game Mode Selected!\r\n");
wait_for_switch_press_and_release();
    show_sudoku_bg(1);
    cy_rgb_led_init(P0_3,P1_1,P11_1,false);

    cy_rgb_led_on(box_color[1], CY_RGB_LED_MAX_BRIGHTNESS);
    /* Notify the audio task to play tone. */
    xTaskNotify(audio_task_handle, 1u, eSetValueWithoutOverwrite);

    sudoku_load(game_mode);

    printf("The Game Loaded!\r\n");
    rtos_api_result = xTimerStartFromISR(game_timer_handle, 0u);
    if(pdFAIL == rtos_api_result)
    {
        printf("Failed to start game timer!\r\n");
        CY_ASSERT(0u);
    }
    for(;;)
    {

        /* Block until a command has been received over queue */
        result = xQueueReceive(gui_capsense_data_q, &gui_cap_data,
                            portMAX_DELAY);

			if(gui_cap_data.buttonstatus1 == 1)
			{

				if(cyhal_gpio_read(CYBSP_USER_BTN) == CYBSP_BTN_PRESSED)
				{
					if(xinc!=0)xinc--;
				}
				else
				{

					if(yinc!=0)yinc--;
				}

				goto_box(xinc, yinc);
			    /* Notify the audio task to play tone. */
			    xTaskNotify(audio_task_handle, 0u, eSetValueWithoutOverwrite);


			}
			else if(gui_cap_data.buttonstatus1== 2)
			{
				if(cyhal_gpio_read(CYBSP_USER_BTN) == CYBSP_BTN_PRESSED)
				{
					if(xinc<5)xinc++;
				}
				else
				{
					if(yinc<5)yinc++;
				}
				goto_box(xinc, yinc);
			    /* Notify the audio task to play tone. */
			    xTaskNotify(audio_task_handle, 0u, eSetValueWithoutOverwrite);


			}
			else if(gui_cap_data.buttonstatus1== 0)
			{
				color_index = (gui_cap_data.sliderdata/30) + 1;
				cy_rgb_led_set_color(led_color[color_index]);
				fill_box(index_now.current.xval,index_now.current.yval,color_index);
				//printf("New index x= %d, y= %d!\r\n",new->xval,new->yval);
				GUI_Delay(100);
				printf("Gui update with slider %d!\r\n",gui_cap_data.sliderdata);
			}

			if(gui_cap_data.buttonstatus2 == 1)
			{
		        GUI_SetFont(GUI_FONT_24B_1);
		        GUI_SetBkColor(GUI_WHITE);
		        GUI_SetTextAlign(GUI_TA_HCENTER);
		        GUI_SetColor(GUI_BLACK);
		        sec = game_timer % 60;
		        min = (game_timer/60) % 60;

		        timer_str[0] = min/10 + '0';
		        timer_str[1] = min%10 + '0';

		        timer_str[3] = sec/10 + '0';
		        timer_str[4] = sec%10 + '0';

		        GUI_DispStringAt(timer_str, 272, 100);

			}
			solved = check_result(game_mode);
			printf("Game Status: %d !\r\n",solved);
			if(solved == 0 || (sec == 0 && min==0))
			{
				if(solved !=0)
				{
					score = (36 - solved) * (game_mode+1);
				}
				else
				{
					score = (game_mode+1)*(60 - sec) + (game_mode+1)*(60 - min);
				}
				printf("Your Time is: %2d:%2d !\r\n",min,sec);
				printf("Your Score is: %3d !\r\n",score);
				printf("The Game Over!\r\n");
			    /* Notify the audio task to play tone. */
			    xTaskNotify(audio_task_handle, 2u, eSetValueWithoutOverwrite);

				score_str[0] = score%10 + '0';
				score_str[1] = (score/10)%10 + '0';
				score_str[2] = (score/100)%10 + '0';

			    show_sudoku_bg(0);
				GUI_DrawBitmap(&bmgame_over_restart_active, 74, 32);
		        GUI_SetFont(GUI_FONT_24B_1);
		        GUI_SetBkColor(GUI_WHITE);
		        GUI_SetTextAlign(GUI_TA_HCENTER);
		        GUI_SetColor(GUI_BLACK);
		        GUI_DispStringAt("YOUR SCORE IS ", 92, 154);
		        GUI_DispString(score_str);

		        /* Stop the timer */
				rtos_api_result = xTimerStop(game_timer_handle, 0u);
				if(pdFAIL == rtos_api_result)
				{
				  printf("Failed to stop game timer!\r\n");
				  CY_ASSERT(0u);
				}
				wait_for_switch_press_and_release();
				break;
			}


			vTaskDelay(10);
    }
}

/*******************************************************************************
* Function Name: fill_box
********************************************************************************
*
* Summary: This function to load initial puzzle.
*
* Parameters: type - game type
*
* Return:
*  None
*
*******************************************************************************/

void sudoku_load(uint8_t type)
{
	uint8_t row,col;

	switch(type)
	{

	case 0:

		for(row=0;row<6;row++)
		{

			for(col=0;col<6;col++)
			{
				fill_boxOnly(row,col,sudoku_table_easy[row][col]);
			}

		}
		break;

	case 1:

		for(row=0;row<6;row++)
		{

			for(col=0;col<6;col++)
			{
				fill_boxOnly(row,col,sudoku_table_medium[row][col]);
			}

		}
		break;

	case 2:

		for(row=0;row<6;row++)
		{

			for(col=0;col<6;col++)
			{
				fill_boxOnly(row,col,sudoku_table_hard[row][col]);
			}

		}
		break;

	default:
		break;

	}


}

/*******************************************************************************
* Function Name: goto_box
********************************************************************************
*
* Summary: This function to move the highlight to given box position.
*
* Parameters: x, y - input parameters
*
* Return:
*  None
*
*******************************************************************************/

void goto_box(uint8_t x, uint8_t y)
{

    index_now.current.xval = x;
    index_now.current.yval = y;

    GUI_SetColor(box_color[sudoku_table_now[index_now.previous.xval][index_now.previous.yval]]);

    GUI_FillCircle(cur_index[index_now.previous.xval][index_now.previous.yval].xval,
    			   cur_index[index_now.previous.xval][index_now.previous.yval].yval, 4);

    if(game_mode == 0)
    {
    	if(sudoku_table_easy[x][y] != 0)
    	{

    	    GUI_SetColor(GUI_GRAY_AA);
    	}
    	else
    	{
    	    GUI_SetColor(GUI_WHITE);
    	}
    }

    if(game_mode == 1)
    {
    	if(sudoku_table_medium[x][y] != 0)
    	{

    	    GUI_SetColor(GUI_GRAY_AA);
    	}
    	else
    	{
    	    GUI_SetColor(GUI_WHITE);
    	}
    }

    if(game_mode == 2)
    {
    	if(sudoku_table_hard[x][y] != 0)
    	{

    	    GUI_SetColor(GUI_GRAY_AA);
    	}
    	else
    	{
    	    GUI_SetColor(GUI_WHITE);
    	}
    }

    GUI_FillCircle(cur_index[index_now.current.xval][index_now.current.yval].xval,
    			   cur_index[index_now.current.xval][index_now.current.yval].yval,  4);

	index_now.previous.xval = index_now.current.xval;
	index_now.previous.yval = index_now.current.yval;

    printf("current index x=%d, y= %d !\r\n",index_now.current.xval,index_now.current.yval);
    printf("previous index x=%d, y= %d !\r\n",index_now.previous.xval,index_now.previous.yval);
}


/*******************************************************************************
* Function Name: fill_box
********************************************************************************
*
* Summary: This function to get the index.
*
* Parameters: None
*
* Return: points - get the current index value
*  None
*
*******************************************************************************/

points_t* get_current_index(void)
{
	points_t *index;

	index->xval = index_now.current.xval;
    index->yval = index_now.current.yval;
	return index;
}

/*******************************************************************************
* Function Name: fill_boxOnly
********************************************************************************
*
* Summary: This function to fill the color  without mark in the given index.
*
* Parameters: row, col, index - input parameters
*
* Return:
*  None
*
*******************************************************************************/

void fill_boxOnly(uint8_t row,uint8_t col, uint8_t color_index)
{

    //GUI_SetBkColor(sudoku_table_now[row][col]);
    GUI_SetColor(box_color[color_index]);
	GUI_FillRect(table_index[row][col].xval, table_index[row][col].yval , table_index[row][col].xval + 35, table_index[row][col].yval + 35);
	if(color_index != 0 ){
	GUI_SetColor(GUI_GRAY);
	GUI_DrawRect(table_index[row][col].xval +3, table_index[row][col].yval + 3 , table_index[row][col].xval + 32, table_index[row][col].yval + 32);
	}
	sudoku_table_now[row][col] = color_index;

}


/*******************************************************************************
* Function Name: fill_box
********************************************************************************
*
* Summary: This function to fill the color in the given index.
*
* Parameters: row, col, index - input parameters
*
* Return:
*  None
*
*******************************************************************************/

void fill_box(uint8_t row,uint8_t col, uint8_t color_index)
{

	if(game_mode == 0)
	{

		if(sudoku_table_easy[row][col] == 0)
		{

		//GUI_SetBkColor(sudoku_table_now[row][col]);
		GUI_SetColor(box_color[color_index]);
		GUI_FillRect(table_index[row][col].xval, table_index[row][col].yval , table_index[row][col].xval + 35, table_index[row][col].yval + 35);
		sudoku_table_now[row][col] = color_index;
		GUI_SetColor(GUI_WHITE);
		GUI_FillCircle(cur_index[row][col].xval,
					   cur_index[row][col].yval,  4);

		}

	}

	if(game_mode == 1)
	{

		if(sudoku_table_medium[row][col] == 0)
		{

		//GUI_SetBkColor(sudoku_table_now[row][col]);
		GUI_SetColor(box_color[color_index]);
		GUI_FillRect(table_index[row][col].xval, table_index[row][col].yval , table_index[row][col].xval + 35, table_index[row][col].yval + 35);
		sudoku_table_now[row][col] = color_index;
		GUI_SetColor(GUI_WHITE);
		GUI_FillCircle(cur_index[row][col].xval,
					   cur_index[row][col].yval,  4);

		}

	}

	if(game_mode == 2)
	{

		if(sudoku_table_hard[row][col] == 0)
		{

		//GUI_SetBkColor(sudoku_table_now[row][col]);
		GUI_SetColor(box_color[color_index]);
		GUI_FillRect(table_index[row][col].xval, table_index[row][col].yval , table_index[row][col].xval + 35, table_index[row][col].yval + 35);
		sudoku_table_now[row][col] = color_index;
		GUI_SetColor(GUI_WHITE);
		GUI_FillCircle(cur_index[row][col].xval,
					   cur_index[row][col].yval,  4);

		}

	}



}


/*******************************************************************************
* Function Name: void wait_for_switch_press_and_release(void)
********************************************************************************
*
* Summary: This implements a simple "Wait for button press and release"
*           function.  It first waits for the button to be pressed and then
*           waits for the button to be released.
*
* Parameters:
*  None
*
* Return:
*  None
*
* Side Effects:
*  This is a blocking function and exits only on a button press and release
*
*******************************************************************************/
void wait_for_switch_press_and_release(void)
{
    /* Wait for SW2 to be pressed */
    while(cyhal_gpio_read(CYBSP_USER_BTN) == CYBSP_BTN_PRESSED)
    {
    	vTaskDelay(100);
    }

    /* Wait for SW2 to be released */
    while(cyhal_gpio_read(CYBSP_USER_BTN) == CYBSP_BTN_OFF)
    {
    	vTaskDelay(100);
    }
}

/*******************************************************************************
* Function Name: void show_sudoku_bg
********************************************************************************
*
* Summary: This function loads the puzzle background
*
* Parameters: index - index of background
*
* Return:
*  None
*
*******************************************************************************/
void show_sudoku_bg(uint8_t index)
{
    /* Set background color to black and clear screen */
    GUI_SetBkColor(GUI_BLACK);
    GUI_Clear();

    switch(index)
    {
    case 0:
        /* Display the bitmap image on the screen */
        GUI_DrawBitmap(&bmsudoku_bg1b, 0, 0);
    	break;
    case 1:
        /* Display the bitmap image on the screen */
        GUI_DrawBitmap(&bmsudoku_bg3, 0, 0);
    	break;
    case 2:
        /* Display the bitmap image on the screen */
        GUI_DrawBitmap(&bmsudoku_bg1b, 0, 0);
    	break;
    default:
    	break;
    }


    /* Set font size, font color to black */
    GUI_SetFont(GUI_FONT_16B_1);
    GUI_SetColor(GUI_BLACK);

}

/* END OF FILE */
